{"version":3,"sources":["shiterate.js"],"names":[],"mappings":";;;;;;;;;AASA;;;;AAEA,OAAO,OAAP,GAAiB,UAAU,KAAV,EAAiB,QAAjB,EAA2B,IAA3B,EAAiC;;;;;;;AAOhD,MAAI,CAAC,MAAM,OAAN,CAAc,KAAd,CAAD,EAAuB;AACzB,UAAM,IAAI,SAAJ,CACJ,4CAA2C,qDAA3C,GAAmD,GAAnD,CADF,CADyB;GAA3B;;;;;;;AAPgD,MAiB5C,OAAO,QAAP,KAAoB,UAApB,EAAgC;AAClC,UAAM,IAAI,SAAJ,CACJ,iDAAgD,2DAAhD,GAA2D,GAA3D,CADF,CADkC;GAApC;;;;;;;AAjBgD,MA2B5C,QAAQ,OAAO,IAAP,KAAgB,UAAhB,EAA4B;AACtC,UAAM,IAAI,SAAJ,CACJ,6CAA4C,mDAA5C,GAAmD,GAAnD,CADF,CADsC;GAAxC;;;;;;;;AA3BgD,MAsC5C,UAAU,MAAM,KAAN,CAAY,CAAZ,CAAV;;;;;;;;AAtC4C,MA8C5C,YAAY,QAAZ;;;;;;;;AA9C4C,MAsD5C,QAAQ,IAAR;;;;;;;;;;AAtD4C,WAgEvC,KAAT,GAAiB;AACf,QAAI,QAAQ,MAAR,EAAgB;AAClB,aAAO,SAAS,CAAT,CAAP,CADkB;KAApB,MAEO;AACL,aAAO,SAAP,CADK;KAFP;GADF;;;;;;;;;;;AAhEgD,WAiFvC,QAAT,CAAkB,CAAlB,EAAqB;AACnB,WAAO,UAAU,QAAQ,CAAR,CAAV,EAAsB,CAAtB,EAAyB,MAAM,CAAN,CAAzB,CAAP,CADmB;GAArB;;;;;;;;;;;AAjFgD,WA8FvC,KAAT,CAAe,CAAf,EAAkB;AAChB,QAAI,gBAAJ,CADgB;;AAGhB,WAAO,MAAM,CAAN,CAAP,CAHgB;AAIhB,SAAK,KAAL,GAAa,OAAO,CAAP,CAAb,CAJgB;;AAMhB,WAAO,IAAP,CANgB;GAAlB;;;;;;;;;;;AA9FgD,WAgHvC,KAAT,CAAe,CAAf,EAAkB;AAChB,WAAO,aAAa,GAAb,EAAkB,YAAM;AAC7B,UAAI,IAAI,MAAM,MAAN,EAAc;AACpB,eAAO,SAAS,CAAT,CAAP,CADoB;OAAtB,MAEO;AACL,eAAO,SAAP,CADK;OAFP;KADuB,CAAzB,CADgB;GAAlB;;;;;;;;;;AAhHgD,WAkIvC,MAAT,CAAgB,CAAhB,EAAmB;AACjB,WAAO,aAAa,GAAb,EAAkB,YAAM;AAC7B,aAAO,SAAP,CAD6B;KAAN,CAAzB,CADiB;GAAnB;;;;;;;;;;AAlIgD,WAgJvC,YAAT,CAAsB,CAAtB,EAAyB,EAAzB,EAA6B;AAC3B,WAAO,oBAAY;AACjB,UAAI,OAAO,QAAP,KAAoB,WAApB,EAAiC;AACnC,gBAAQ,CAAR,IAAa,QAAb,CADmC;OAArC;;AAIA,WALiB;KAAZ,CADoB;GAA7B;;;;;;;;;AAhJgD,WAiKvC,OAAT,GAAmB;AACjB,QAAI,KAAJ,EAAW;AACT,aAAO,MAAM,OAAN,CAAP,CADS;KAAX;GADF;;AAMA,UAvKgD;CAAjC","file":"shiterate.js","sourcesContent":["/**\n * Shiterate module definition.\n *\n * @module shiterate\n * @exports {Function}\n * @author Nathan Buchar <hello@nathanbuchar.com>\n * @license MIT\n */\n\n'use strict';\n\nmodule.exports = function (array, iteratee, done) {\n\n  /**\n   * Validate that the \"array\" parameter is an array.\n   *\n   * @throws\n   */\n  if (!Array.isArray(array)) {\n    throw new TypeError(\n      '\"array\" must be an array. Got \"' + typeof array + '\"');\n  }\n\n  /**\n   * Validate that the \"iteratee\" parameter is a function.\n   *\n   * @throws\n   */\n  if (typeof iteratee !== 'function') {\n    throw new TypeError(\n      '\"iteratee\" must be a function. Got \"' + typeof iteratee + '\"');\n  }\n\n  /**\n   * Validate that the \"done\" parameter is a function, if it is defined.\n   *\n   * @throws\n   */\n  if (done && typeof done !== 'function') {\n    throw new TypeError(\n      '\"done\" must be a function. Got \"' + typeof done + '\"');\n  }\n\n  /**\n   * Internal reference to the sliced array that we will be querying.\n   *\n   * @type {Array}\n   * @private\n   */\n  let _sliced = array.slice(0);\n\n  /**\n   * Internal reference to the function invoked per iteration.\n   *\n   * @type {Function}\n   * @private\n   */\n  let _iteratee = iteratee;\n\n  /**\n   * Internal reference to the function invoked when finished.\n   *\n   * @type {Function}\n   * @private\n   */\n  let _done = done;\n\n  /**\n   * Initializes the shiterator. :poop:\n   *\n   * @see _iterate\n   * @see _finish\n   * @returns {Function}\n   * @private\n   */\n  function _init() {\n    if (_sliced.length) {\n      return _iterate(0);\n    } else {\n      return _finish();\n    }\n  }\n\n  /**\n   * Invokes the given iteratee with the current array index, value, and the\n   * \"next\" Object tailored to the current index.\n   *\n   * @see _step\n   * @param {number} n\n   * @returns {Function}\n   * @private\n   */\n  function _iterate(n) {\n    return _iteratee(_sliced[n], n, _step(n));\n  }\n\n  /**\n   * Creates the \"next\" Object that is tailored to the current index.\n   *\n   * @see _next\n   * @see _abort\n   * @param {number} n\n   * @returns {Object} next\n   * @private\n   */\n  function _step(n) {\n    let next;\n\n    next = _next(n);\n    next.abort = _abort(n);\n\n    return next;\n  }\n\n  /**\n   * Updates the value of the current item, then iterates to the next array item\n   * or terminates if it's reached the end.\n   *\n   * @see _updateValue\n   * @param {number} n\n   * @returns {Function}\n   * @private\n   */\n  function _next(n) {\n    return _updateValue(n++, () => {\n      if (n < array.length) {\n        return _iterate(n);\n      } else {\n        return _finish();\n      }\n    });\n  }\n\n  /**\n   * Updates the value of the current item, then terminates the iterator.\n   *\n   * @see _updateValue\n   * @param {number} n\n   * @returns {Function}\n   * @private\n   */\n  function _abort(n) {\n    return _updateValue(n++, () => {\n      return _finish();\n    });\n  }\n\n  /**\n   * Updates the value of the array item at the given index.\n   *\n   * @param {number} n\n   * @param {Function} fn\n   * @returns {Function}\n   * @private\n   */\n  function _updateValue(n, fn) {\n    return newValue => {\n      if (typeof newValue !== 'undefined') {\n        _sliced[n] = newValue;\n      }\n\n      fn();\n    };\n  }\n\n  /**\n   * Final exit point for the iteration, whether it was terminated or not. Calls\n   * the \"done\" callback if it was defined.\n   *\n   * @returns {Function} _done\n   * @private\n   */\n  function _finish() {\n    if (_done) {\n      return _done(_sliced);\n    }\n  }\n\n  _init();\n};\n"],"sourceRoot":"/source/"}